(defun stringify (x)
  (try
   (js-code "JSON.stringify(d$$x)")
   "'**UNABLE-TO-STRINGIFY**'"))

(defun literal(k)
  (stringify (js-code "lisp_literals[parseInt(d$$k.substr(1))]")))

(defun variable(k)
  (stringify (js-code "glob['d'+d$$k]")))

(defun symbol(k)
  (stringify (js-code "glob[d$$k]")))

(defun fclosure (x)
  (do ((result (js-object))
       (vars (js-object))
       (todo (list x))
       (litout false))
      ((empty todo)
         (dolist (k (sort (keys vars)))
           (cond
             ((= (aref k 0) "q")
              (unless litout
                (setf litout true)
                (display "lisp_literals=[];"))
              (display ~"lisp_literals[{(slice k 1)}]={(literal k)};"))
             ((= (aref k 0) "s")
              (display ~"{k}={(symbol k)};"))
             (true
              (display ~"d{k}={(variable k)};"))))
         (dolist (k (sort (keys result)))
           (display ~"f{k}={(aref result k)};"))
         result)
    (let ((new-todo (list)))
      (dolist (x todo)
        (setf (aref result (. x name))
              (or (and (symbol-function x)
                       (+ (symbol-function x) ""))
                  "**N/A**"))
        (dolist (v (or (and (symbol-function x)
                            (. (symbol-function x) usedglobs))
                       (list)))
          (setf (aref vars v) true))
        (dolist (fn (or (and (symbol-function x)
                             (. (symbol-function x) outcalls))
                        (list)))
          (unless (aref result fn)
            (let* ((i (index "$$" fn))
                   (y (intern (demangle fn) (slice fn 0 i))))
              (push y new-todo)))))
      (setf todo new-todo))))