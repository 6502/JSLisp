<!DOCTYPE HTML>
<html>
  <!--
/****************************************************************************\
******************************************************************************
**                                                                          **
**  Copyright (c) 2011 by Andrea Griffini                                   **
**                                                                          **
**  Permission is hereby granted, free of charge, to any person obtaining   **
**  a copy of this software and associated documentation files (the         **
**  "Software"), to deal in the Software without restriction, including     **
**  without limitation the rights to use, copy, modify, merge, publish,     **
**  distribute, sublicense, and/or sell copies of the Software, and to      **
**  permit persons to whom the Software is furnished to do so, subject to   **
**  the following conditions:                                               **
**                                                                          **
**  The above copyright notice and this permission notice shall be          **
**  included in all copies or substantial portions of the Software.         **
**                                                                          **
**  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,         **
**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF      **
**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                   **
**  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE  **
**  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION  **
**  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION   **
**  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.         **
**                                                                          **
******************************************************************************
\****************************************************************************/
    -->
  <head>
    <title>JSLisp REPL</title>
  </head>
  <body>
    <div style="position:absolute; left:0px; top:0px; right:0px; bottom:0px; padding:4px; background-color:#EEEEEE">
      <textarea type=text wrap=off id="repl" style="white-space:pre; width:100%; height:100%; background-color:#EEEEEE; border:none; outline:none; padding:0px; margin:0px; font-family:Courier New; font-size:18px"
        onkeydown = "keyDown(event)"
        onkeypress = "keyPress(event)"></textarea>
      <div id="clpar" style="position:absolute; width:22px; height:22px; border:solid 1px #FF0000"></div>
    </div>
    <script src="jslisp.js">
    </script>
    <script>

var char_width, char_height;

(function(){
    var nta = document.createElement("textarea");
    nta.style.fontFamily = "Courier New";
    nta.style.fontSize = "18px";
    document.body.appendChild(nta);
    nta.rows = 10; nta.cols = 10;
    var w1 = nta.offsetWidth, h1 = nta.offsetHeight;
    nta.rows = 20; nta.cols = 20;
    var w2 = nta.offsetWidth, h2 = nta.offsetHeight;
    document.body.removeChild(nta);
    char_width = (w2 - w1) / 10;
    char_height = (h2 - h1) / 10;
})();

var prompt = "Ready.";
var repl = document.getElementById("repl");
var clpar = document.getElementById("clpar");
repl.focus();

var indent_rules = {
    "defun": [1],
    "defmacro": [1],
    "defstruct": [1],
    "let": [1],
    "let*": [1],
    "do": [3,3,1],
    "dotimes": [1],
    "dolist": [1],
    "lambda": [1],
    "labels": [1],
    "when": [1],
    "unless": [1],
    "": [0],
};

function updateClpar(text)
{
    var i = 0;
    if (text == undefined)
    {
        text = repl.value.substr(0, repl.selectionStart);
        var li = text.lastIndexOf("\n"+prompt+"\n");
        if (li != -1) i = li + 2 + prompt.length;
    }

    var indent = [];
    var skip_spaces = function()
    {
        while (i < text.length && " \r\n\t".indexOf(text[i]) != -1)
            ++i;
    };

    var parse = function()
    {
        skip_spaces();
        if (text[i] == '(')
        {
            var fsp = Math.min((text+" ").indexOf(" ", i+1),
                               (text+"(").indexOf("(", i+1));
            if (fsp == -1) fsp = i+1;
            var rules = indent_rules[text.substr(i+1, fsp-i-1)] || null;
            var ii = [i, 0, i+2]; // Indent info: start, arg index, indent
            indent.push(ii);
            ++i;
            skip_spaces();
            while (i < text.length && text[i] != ')')
            {
                ++ii[1];
                if (rules)
                {
                    // Indentation as specified by the rule
                    ii[2] = ii[0] + rules[Math.min(ii[1]-1, rules.length-1)];
                }
                else if (ii[1] == 2)
                {
                    // No special rules... align on start of first parameters
                    ii[2] = i-1;
                }

                parse();
                skip_spaces();
            }
            i++;
            if (i >= text.length)
                throw indent;
            indent.pop();
        }
        else if (text[i] == '"' || text[i] == '|')
        {
            var q = text[i++];
            while (i < text.length && text[i] != q)
            {
                if (text[i] == '\\') i++;
                i++;
            }
            i++;
        }
        else if (text[i] == ';')
        {
            while (i < text.length && text[i] != '\n')
                i++;
            i++;
        }
        else if (text[i] == '#')
        {
            i++;
            if (text[i] == '\\') i+=2;
            while (i < text.length && "() \t\n\r".indexOf(text[i]) == -1)
                i++;
        }
        else
        {
            while (i < text.length && "() \t\n\r".indexOf(text[i]) == -1)
                i++;
            while (indent.length == 0 && i < text.length && text[i] == ')')
                i++;
        }
    };

    try
    {
        while (i < text.length)
            parse();
    }
    catch(indent)
    {
        if (text[text.length-1] == ")")
        {
            var s = indent[indent.length-1][0];
            var before = text.substr(0, s);
            var y = char_height * (before.replace(/[^\n]/g,"").length);
            var x = char_width * (before.length - ("\n" + before).lastIndexOf("\n"));
            clpar.style.left = (repl.offsetLeft + x - repl.scrollLeft - 1) + "px";
            clpar.style.top = (repl.offsetTop + y - repl.scrollTop - 1) + "px";
            clpar.style.width = char_width + "px";
            clpar.style.height = char_height + "px";
            clpar.style.display = "block";
            indent.pop();
        }
        else
        {
            clpar.style.display = "none";
        }
        if (indent.length == 0)
            return 0;
        var i = indent[indent.length-1][2];
        return i - text.lastIndexOf("\n", i);
    }
    clpar.style.display = "none";
    return 0;
}

setInterval(function(){updateClpar();}, 100);

function htmlesc(x)
{
    return (x
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/ /g, "&nbsp;")
            .replace(/\n/g, "<br/>"));
}

function f$$display(x)
{
    repl.value += x + "\n";
    var i = repl.value.length;
    repl.setSelectionRange(i, i);
    repl.scrollTop = repl.scrollHeight;
    repl.focus();
    return x;
};

function process()
{
    var base = repl.value;
    var li = base.lastIndexOf("\n"+prompt+"\n");
    base = base.substr(li == -1 ? 0 : li+2+prompt.length).replace(/\t\n *$/,"");
    try
    {
        var src = f$$reader_function(base);
        f$$skip_spaces(src);
        while (src() != undefined)
        {
            var parsed = f$$parse_value(src);
            var compiled = f$$js_compile(parsed);
            var result = eval(compiled);
            f$$display("--> " + f$$str_value(result));
            f$$skip_spaces(src);
        }
    }
    catch (err)
    {
        err = ("" + err).replace(/[dmf]\$\$([a-zA-Z_]|(\$[0-9]+\$))*/g,
                                 function(s)
                                 {
                                     return {"d" : "",
                                             "m" : "macro ",
                                             "f" : "function "}[s[0]] + f$$demangle(s.substr(1));
                                 });
        f$$display("**ERROR**: " + err);
    }
    f$$display(prompt);
}

function keyDown(e)
{
    if (e.which == 9)
    {
        e.preventDefault();
        var text = repl.value;
        var ss = repl.selectionStart;
        var se = repl.selectionEnd;
        var lines = text.split("\n");
        var before = text.substr(0, ss).replace(/[^\n]/g,"").length;
        var after = 1 + text.substr(0, se).replace(/[^\n]/g,"").length;
        var nt = lines.slice(0, before).join("\n"); if (before) nt += "\n";
        var ns = nt.length;
        for (var i=before; i<after; i++)
        {
            indent = updateClpar(nt);
            var sp = "";
            while (indent > 0)
            {
                --indent;
                sp += " ";
            }
            var L = lines[i];
            while (L[0] == ' ') L = L.substr(1);
            nt += sp + L + "\n";
        }
        var ne = nt.length-1;
        nt += lines.slice(after).join("\n");
        while (nt[nt.length-1] == "\n")
            nt = nt.substr(0, nt.length-1);
        repl.value = nt;
        repl.setSelectionRange(ne, ne);
        repl.focus();
    }
}

function keyPress(e)
{
    if (e.which == 10 || (e.which == 13 && (e.ctrlKey || e.shiftKey)))
    {
        process();
        e.preventDefault();
    }
    else if (e.which == 13)
    {
        e.preventDefault();
        var level = updateClpar();
        var text = repl.value;
        var i = repl.selectionStart;
        var sp = "";
        for (var j=0; j<level; j++)
            sp += " ";
        repl.value = text.substr(0, i) + "\n" + sp + text.substr(i);
        repl.setSelectionRange(i + 1 + sp.length, i + 1 + sp.length);
        if (sp == "" && repl.selectionStart == repl.value.length)
            process();
        repl.scrollTop = repl.scrollHeight;
    }
}

function f$$ajax(url, cback, error)
{
    var xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange=function()
    {
        if (xmlhttp.readyState == 4)
        {
            if (xmlhttp.status == 200)
            {
                cback(xmlhttp.responseText);
            }
            else
            {
                if (error)
                {
                    error(xmlhttp.status);
                }
                else
                {
                    alert("Ajax request error: status=" + xmlhttp.status);
                }
            }
        }
    };
    xmlhttp.open("GET", url, true);
    xmlhttp.send();
}

// Bootstrap
f$$ajax("boot.lisp",
        function(boot)
        {
            try
            {
                f$$load(boot);
                f$$display("Boot completed");
            }
            catch(err)
            {
                f$$display("Bootstrap error: " + err);
            }
            f$$display(prompt);
        },
        function(err)
        {
            f$$display("Bootstrap ajax error: status=" + err)
            f$$display(prompt);
        });
    </script>
  </body>
</html>
