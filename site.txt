@ About

JsLisp is a Lisp(1) Compiler(3) targeting Javascript(3)

In more detail...

# (1) A Lisp

JsLisp is a Lisp-2, similar to Common Lisp but is not Common Lisp

- Symbols are case sensitive.
- No cons cells. Lists are represented using Javascript lists.
- Lists are first-class objects. [push] is a regular function.
- No numeric tower. Numbers are double-precision floats (they provide
  53 bits of integer numeric accuracy).
- Dynamic and lexical variables.
- There can be both a function and a macro with the same name. Macro
  is used in explicit calls, function can be used for [funcall]/[apply].
- [NaN], [null], [undefined], [false], [0] are present with their
  Javascript value semantic.
- No [NIL]/[T]. Truth values are Javscript [true]/[false].
- [defmacro], [define-symbol-macro], [macrolet], [symbol-macrolet] are
  present mimicking Common Lisp semantic. Quasiquoting.
- Read macros.
- Interpolated string literals.
- No [loop] macro for now.

# (2) Compiler

JsLisp is a compile-only implementation and contains no interpreter,
[eval] is implemented by compiling and executing.  The core of the
compiler is hand-written Javascript, everything else is written in
JsLisp itself (boot.lisp).

Compiled functions are regular Javscript functions, callable from
Javascript code (with the exception of keyword arguments) and that
can call Javascript code.

Javascript inlining is possible and used heavily in the default
runtime library. Name mangling is necessary when converting JsLisp
symbol names to Javascript and vice versa [(mangle x)]/[(demangle x)].

Support for docstrings, parameter checking (done at compile time on
static calls), [&key]/[&optional]/[&rest] parameters.

# (3) Targeting Javascript

No attempt is made to create human-readable idiomatic Javascript,
generated code is not meant to be manually maintained.

Works with recent browsers and node.js.

Any Javascript functions or methods can be called from JsLisp code by
using the generic binding facility [bind-js-functions] and
[bind-js-methods].

@ License

I am not a lawyer and I just hope this is enough to leave me out
of jail... if you think it's not, then please drop me a line.

The intention is that you can use JsLisp for whatever you want
(commercial or not) provided you just don't pretend you did something
that I did or that you blame me if you have any problem.

<<
<div style="border:solid 2px #000080; background-color:#EEEEFF;
            padding:12px; font-size:120%">
<p>Copyright (c) 2012 by Andrea Griffini</p>

<p>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:</p>

<ol>
<li style="margin-bottom:20px">
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</li>

<li style="font-weight:bold">
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</li></ol>
</div>
>>

@ Examples

These are a few examples of JsLisp programs. Unless noted otherwise
a recent HTML5 browser is required.

!Naive Fibonacci computation:fibo.lisp
!Memoization:memoize.lisp
!An interactive 3d Rubik cube:3d.lisp
!A pie chart builder:piechart.lisp
!A simple messagebox:guitest.lisp
!A turtle graphic implementation:turtle.lisp

@ JsLisp <=> CL

In this sections the differences between Common Lisp and JsLisp will
be explained in more detail. This is not meant to be a tutorial on
Lisp and a fairly decent understanding of Lisp is assumed.

## Main JsLisp philosophy

The main idea behind JsLisp was to create a Lisp system starting from
Javascript (instead of starting from IBM 704 instruction set) and
trying to become similar to Common Lisp up to the point where the
Javascript machine below would like to start complaining about that.

So basically the target of JsLisp was to become "as close as
reasonably possible to CL, but not closer".

Please also consider that current state of JsLisp is extremely flux
and subject to change. A few parts are departures from CL that I'm not
fully convinced about.

@@ No CAR / CDR

In JsLisp there is no [cons], no [car] and no [cdr]. I'm not joking.
I'm not talking about just the name [car]/[first] or
[cdr]/[rest]... but about the very concept of linked list made of cons
cells that is typical of most if not all other Lisp dialects.

OK. Please start breathing again. This is not a fundamental departure
from Lisp. Really.

There is nothing "essential" into using cons cells except a conceptual
and formal minimality that represents a model neither our human brain
nor the today computer brain finds particularly simple.

Don't get me wrong. I think this was a fantastic smart choice for the
problem McCarthy was working on, but for both humans and most current
computers the array is a much more fundamental block than a linked
list. To understand a cons cell you need to conceive the idea of two
parts stuck together, then why not thinking to several (any n >= 0)
parts stuck together instead of building a chain?

JsLisp uses Javascript array objects to represent lists and lists are
mutable first-class objects. [push] in JsLisp can a be simple function
and doesn't need to be necessarily a macro.  Moreover [push] and [pop]
are defined to work like they naturally do in Javascript by adding and
removing elements at the end.

There are of course both [reverse] and [nreverse] available, but
they're much less needed than in Common Lisp because after pushing
things in a list they're already in the correct order.

Sharing is still possible and happens often with nested list
structures, but only at subtree level and not at the tail level.
Still for example is not safe to assume that quasiquoting will return
a fresh unshared tree structure.

For representing code and in many cases in which sharing is not
essential this approach is much more efficient than using cons cells
to build lists and it's also the way the underlying "hardware" works
(Javascript).

Creating cells-based linked lists is of course possible for example
using two-elements arrays and can be a sensible choice if the
tail-sharing possibilities are playing an important role for your
problem.

@@ Lisp-3

In JsLisp there are three main values for a symbol: the value, the
function and the macro. In JsLisp is therefore possible to have both a
function and a macro sharing the same name.

The macro is used (if present) every time a static call form is
compiled, while the function is used instead every time a [(function
...)] form is used to pass or store away the function.

Like in Common Lisp the call [(symbol-function x)] returns the global
function associated with the symbol [x] (not considering lexical
function bindings) and [(function x)] abbreviated as usual [#'x]
returns the function binding of the unevaluated symbol [x] those
introduced in a lexical scope.

In a similar way the function [(symbol-macro x)] returns the global
macro associated to the symbol [x] (not considering lexical macros
established by [macrolet]). The current macro binding associated
with the unevaluated symbol [x] is accessible with [(macro x)] and
there is no reader macro for this very infrequent need.

Something that is used quite often in [boot.lisp] is the macro
 [defmacro/f] that allows defining at the same time a macro and a
 function and that but that can be used however only for functions
 with a fixed number of arguments.

[defmacro/f
(defmacro/f square (x)
  (let ((y (gensym)))
    `(let ((,y ,x))
       (* ,y ,y))))
--> square
Ready.
(square 12)
--> 144
Ready.
(macroexpand-1 '(square (+ x y)))
--> (let ((G:12 (+ x y))) (* G:12 G:12))
Ready.
(map #'square (range 10))
--> (0 1 4 9 16 25 36 49 64 81)
Ready.
]

@@ Numbers

JsLisp doesn't provide the Common Lisp numeric tower.

Numbers are just Javascript numbers, i.e. double-precision floating
point values that ensure unit-accurate integer computations "only" up
to [-/+ 9,007,199,254,740,992] (2 to the 53rd power, more than
nine millions of billions).

Also all math functions are simple wrappers of Javascript math
functions and therefore the rules about [NaN] and [null] results
of computations are dictated down there (e.g. [(/ 0) -> null]
but [(log -1) -> NaN]).

@@ Reader

JsLisp reader allows customization like Common Lisp, but using a
different approach.

Parse functions take as only argument a "source" that is a callable
object (closure) that accepts a single integer argument; when passed
[0] it returns the current character in the stream and when passed [1]
advances to next character (still returning the old character).

To read from a string there is a predefined [(reader-function s)]
that returns a suitable closure for scanning the string [s].

Reader customization can be done mainly in two ways:

### 1) Defining a reader function for a character

Consider a classical example of customizing the reader so
that lambda forms can be specified more succintly:

+--------------------+--------------------------+
|        this        |  is interpreted as this  |
+--------------------+--------------------------+
| [{x -> (* x 2)}]   | [(lambda (x) (* x 2))]   |
| [{x y -> (+ x y)}] | [(lambda (x y) (+ x y))] |
| [{+ x 1}]          | [(lambda (x) (+ x 1))]   |
+--------------------+--------------------------+

If an application is using a lot of anonymous functions this
transformation could lead to a subjectively more readable code.

[Reader customization example 1
(setf (reader "{")
      (lambda (src)
        (funcall src 1)
        (let ((form (parse-delimited-list src "}")))
          (let ((i (index '-> form)))
            (if (>= i 0)
                `(lambda ,(slice form 0 i)
                   ,@(slice form (1+ i)))
                `(lambda (x) ,form))))))
--> #CODE
Ready.
(parse-value "{+ x 1}")
--> (lambda (x) (+ x 1))
Ready.
(parse-value "{x y -> (* x y)}")
--> (lambda (x y) (* x y))
Ready.
(map {* x x} (range 10))
--> (0 1 4 9 16 25 36 49 64 81)
Ready.
]

### 2) Redefining (wrapping) the [parse-value] predefined function

The other option is replacing the [parse-value] function that is used
every time JsLisp needs to read from a character source.

For example consider the customization of the reader that handles
symbols containing dots so that for example [document.write] is
interpreted as [(. document write)] allowing a more "usual" access
to DOM property values.

[Redefining parse-value
(setf #'parse-value
      (let ((oldf #'parse-value))
        (lambda (src)
          (let ((x (funcall oldf src)))
            (when (and (symbol? x)
                       (find "." (symbol-name x)))
              (setf x `(. ,@(map #'intern
                                 (split (symbol-name x) ".")))))
            x))))
--> #CODE
Ready.
document.body.style.padding
--> "0px"
Ready.
(parse-value "document.body.style.padding")
--> (. document body style padding)
Ready.
]

@ JsLisp <=> Javascript

Compared to the Javascript language there are many differences.  Most
of the differences are on the syntax level and there are workarounds
(like for example using anonymous functions immediately called to
create local scopes) and this is exactly how the JsLisp compiler
solves the problems.

In other cases the workaround is way too annoying to be implemented
manually in Javascript (due to the lack of macro capabilities) and the
features provided by JsLisp are simply not used in manually written
Javascript code.

@@ Block scope

In JsLisp you can define a variable that is visible only for a block
of code, like in C/C++, without interferring with another variable
with the same name in the containing block.

[BLock scope
// Javascript
function foo ()
{
    var x = 1;
    for (var y = 0; y < 4; y++)
    {
        var x = y * y;
        // ... use x ...
    }
    // Here x content has been destroyed; no matter how many
    // var declarations you put only one x per function
    // instance is allocated.
    // The commonly used approach is to use
    //
    //       (function(){var x = y*y; ... })();
    //
    // instead of just a block.
}

;; JsLisp
(defun foo ()
  (let ((x 1))
    (dotimes (y 4)
       (let ((x (* y y)))
         ;; ... use x ...
       ))
    ;; Here x content is still 1. The x variable inside the
    ;; loop is a different separate value from the external one.
    ;; Every (let ...) form introduces a new scope shielding
    ;; unwanted changes
  ))
]

@@ Arguments

JsLisp supports [&optional], [&rest] and [&key] arguments for functions.
For both [&optional] and [&key] arguments it's possible to provide
a default expression to be used.

[Optional/keyword/rest
(defun foo (x &optional y (z 42))
  (list x y z))
--> foo
Ready.
(foo 1)
--> (1 undefined 42)
Ready.
(foo 1 2 3)
--> (1 2 3)
Ready.
(defun bar (x &key y (z 42))
  (list x y z))
--> bar
Ready.
(bar 1)
--> (1 undefined 42)
Ready.
(bar 1 :z 99)
--> (1 undefined 99)
Ready.
(bar 1 :z 99 :y 33)
--> (1 33 99)
Ready.
(defun baz (x y &rest z)
  (list x y z))
--> baz
Ready.
(baz 1 2 3 4 5)
--> (1 2 (3 4 5))
Ready.
]

@@ Static checks

JsLisp can perform a few static (compile-time) checks that
help avoiding typos in programs. A few of these checks are
about the use of undefined variables or wrong parameters
when calling a function.

It is important to note that these checks are performed
when the function containing the wrong call is compiled,
not when (and no matter if) it's executed.

The checks are also performed at runtime and in that case
the result is an error and not a warning.

[Undefined variables
(defun foo (x)
  (* x y))
WARNING: Undefined variable y
--> foo
Ready.
(foo 12)
**ERROR**: ReferenceError: y is not defined
Ready.
(defvar z 99)
--> 99
Ready.
(defun bar (x)
  (* x z))
--> bar
Ready.
(bar 33)
--> 3267
Ready.
]

[Undefined functions
(defun bar (x)
  (* x (foo (1+ x))))
WARNING: Undefined function foo
--> bar
Ready.
(bar 12)
**ERROR**: ReferenceError: function foo is not defined
Ready.
(defun foo (x) (* x 2))
--> foo
Ready.
(bar 12)
--> 312
Ready.
]

[Wrong parameters in static call
(defun square (x) (* x x))
--> square
Ready.
(defun bar ()
  (square)
  (square 12)
  (square 1 2 3))
WARNING: Not enough arguments in (square)
WARNING: Unexpected arguments in (square 1 2 3)
--> bar
Ready.
(defun foo (x &key y z)
  (list x y z))
--> foo
Ready.
(defun baz ()
  (foo)
  (foo 1)
  (foo 1 :z 2)
  (foo 1 :k 99))
WARNING: Not enough arguments in (foo)
WARNING: Invalid keyword parameter :k in (foo 1 :k 99)
--> baz
Ready.
]

@@ Structures

JsLisp allows the definition of simple data structures
using the [defstruct] macro:

[Defstruct
(defstruct p3d x y (z 99))
--> p3d
Ready.
(make-p3d :x 10)
--> (p3d 10 undefined 99)
Ready.
(let ((p (make-p3d :x 10
                   :y 20))
      (q "hmmm"))
  (display (p3d-x p))
  (incf (p3d-y p))
  (display (str-value p))
  (display (p3d? p))
  (display (p3d? q)))
10
(p3d 10 21 99)
true
false
--> false
Ready.
]

@Javascript integration

JsLisp compiled functions are regular Javascript functions and can
call or be called from Javascript. The only problems are

- Names of the functions defined in JsLisp are "mangled" because
  they may contain characters that cannot be used in Javascript.
  For example the JsLisp function [circle-area] will be seen from
  Javascript as [f$$circle_area] and the predefined JsLisp
  function [1+] is seen from Javascript as [f$$$49$$43$].

- Keyword parameters cannot be easily passed from Javascript to
  JsLisp functions

@@ Simple interfacing

There a simple tool to interface an external Javascript function from
JsLisp:

[Simple javascript interfacing
Ready.
(bind-js-functions Math.sin Math.cos Math.log)
--> Math.log
Ready.
(Math.sin 2)
--> 0.9092974268256817
Ready.
(Math.log 12)
--> 2.4849066497880004
Ready.
(bind-js-functions JSON.stringify)
--> JSON.stringify
Ready.
(JSON.stringify (list 1 2 3))
--> "[1,2,3]"
Ready.
]

@@ Inline Javascript

It is possible to inline Javascript code from JsLisp, note however
that the strings inlined must be string literals and not string
expressions.

Dynamically building Javascript code by string manipulation is done
often in macros (it's actually how the compiler is implemented).
In "leaf" cases the output of a macro is a single [js-code] form.

[Inline Javascript code
(display (+ "Hello "
            (js-code "prompt('What is your name?')")
            ",\nhow's going?"))
=Hello Andrea,
=how's going?
--> "Hello Andrea,\nhow's going?"
Ready.
(macroexpand-1 '(set-aref x 1 42))
WARNING: Undefined variable x
--> (js-code "(d$$x[1]=42)")
Ready.
]

@ Give it a try!

JsLisp REPL can run in most recent web browsers.

This means there is no program to download and to install.

You can start a new fresh JsLisp session in a separate
window by clicking the following button.

<<
<input type=button value="Start JsLisp" onclick="window.open('jslisp.html', '_blank', 'width=800, height=800, left=100, top=100')"/>
>>

If you want to install JsLisp on your own computer unfortunately you
need to use a local web server because for security reasons Ajax
requests are not supported on local filesystem browsing.
