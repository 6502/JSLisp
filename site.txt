@ About

JsLisp is a Lisp(1) Compiler(3) targeting Javascript(3)

In more detail...

# (1) A Lisp

JsLisp is a Lisp-2, similar to Common Lisp but is not Common Lisp

- Symbols are case sensitive.
- No cons cells. Lists are represented using Javascript lists.
- Lists are first-class objects. [push] is a regular function.
- No numeric tower. Numbers are double-precision floats (they provide
  53 bits of integer numeric accuracy).
- Dynamic and lexical variables.
- There can be both a function and a macro with the same name. Macro
  is used in explicit calls, function can be used for [funcall]/[apply].
- [NaN], [null], [undefined], [false], [0] are present with their
  Javascript value semantic.
- No [NIL]/[T]. Truth values are Javscript [true]/[false].
- [defmacro], [define-symbol-macro], [macrolet], [symbol-macrolet] are
  present mimicking Common Lisp semantic. Quasiquoting.
- Read macros.
- Interpolated string literals.
- No [loop] macro for now.

# (2) Compiler

JsLisp is a compile-only implementation and contains no interpreter,
[eval] is implemented by compiling and executing.
The core of the compiler is hand-written Javascript, everything else
is written in JsLisp itself (boot.lisp).

Compiled functions are regular Javscript functions, callable from
Javascript code (with the exception of keyword arrugments) and that
can call Javascript code.

Javascript inlining is possibile and used heavily in the default
runtime library. Name mangling is necessary when converting JsLisp
symbol names to Javascript and viceversa [(mangle x)]/[(demangle x)].

Support for docstrings, parameter checking (done at compile time on
static calls), [&key]/[&optional]/[&rest] parameters.

# (3) Targeting Javascript

No attempt is made to create human-readable idiomatic Javascript,
generated code is not meant to be manually maintained.

Works with recent browsers and node.js.

Any Javascript functions or methods can be called from JsLisp code by
using the generic binding facility [bind-js-functions]/[bind-js-methods].

@ Examples

These are a few examples:

[Fibonacci numbers (naive)
(defun fibo (n)
  "n-th Fibonacci number"
  (if (< n 2)
      1
      (+ (fibo (- n 1))
         (fibo (- n 2)))))
--> fibo
Ready.
(defun test-fibo (n)
  "Displays the first n Fibonacci numbers"
  (dotimes (i n)
    (display ~"(fibo {i}) --> {(fibo i)}")))
--> test-fibo
Ready.
(time (test-fibo 20))
=(fibo 0) --> 1
=(fibo 1) --> 1
=(fibo 2) --> 2
=(fibo 3) --> 3
=(fibo 4) --> 5
=(fibo 5) --> 8
=(fibo 6) --> 13
=(fibo 7) --> 21
=(fibo 8) --> 34
=(fibo 9) --> 55
=(fibo 10) --> 89
=(fibo 11) --> 144
=(fibo 12) --> 233
=(fibo 13) --> 377
=(fibo 14) --> 610
=(fibo 15) --> 987
=(fibo 16) --> 1597
=(fibo 17) --> 2584
=(fibo 18) --> 4181
=(fibo 19) --> 6765
--> 46
Ready.
]

[Generic memoization
(defun memoize (f)
  "Returns a memoized version of function f"
  (let ((cache (js-object)))
    (lambda (&rest args)
      (let ((result (aref cache args)))
        (first (or result
                   (setf (aref cache args)
                         (list (apply f args)))))))))

;; Let's memoize fibo
(setf #'fibo (memoize #'fibo))
(time (fibo 100))
(fibo 100)
]

@ Give it a try!

JsLisp runs in a web browser.

Nothing to download.

Nothing to install.

You can start a new fresh JsLisp session in a separate
window by clicking the following button.

<<
<input type=button value="Start JsLisp" onclick="window.open('jslisp.html', '_blank', 'width=800, height=800, left=100, top=100')"/>
>>

@ JsLisp introduction

## The Read Eval Print Loop

The JsLisp REPL (read-eval-print-loop) is an interactive environment
that can be used to experiment with JsLisp code.
It is implemented using a textarea element in a browser window.

The part in gray is generated by JsLisp, the part in blue instead is
typed in manually.

[REPL example 1
Boot completed.
Ready.
42
--> 42
Ready.
(+ 1 2 3 4)
--> 10
Ready.
(+ 1 (* 2 3))
--> 7
Ready.
]

As you can see the REPL can be used as a calculator. Expressions are
however written using the notation [(operator operand1 operand2 ...)].

In every math expression there is only one operator and many operands,
therefore it doesn't make sense to talk about precedence (like we do
in usual algebra to say that in [1+2*3] the multiplcation must be
done first).

The subtraction [-] and division [/] operators when provided only
one argument behave differently and allow the computation of the
opposite or the reciprocal of a number (respectively).

[Subtraction and division as unary operators
(/ 3)
--> 0.3333333333333333
Ready.
(- (* 21 2))
--> -42
Ready.
]

## Variables

You can define a variable using [(defvar <name> <value>)] syntax:

[Defining a new variable, using a predefined variable
(defvar radius 12)
--> 12
Ready.
(* radius radius pi)
--> 452.3893421169302
Ready.
pi
--> 3.141592653589793
Ready.
]

Note that JsLisp variables are case sensitive (two variables with
the same letters in the name but one lowercase and the other
uppercase are considered different variables). Note also that
any character can be used for variable names.

[Case sensitivity, non-alpha characters in names
(defvar This 13)
--> 13
Ready.
(defvar this 53)
--> 53
Ready.
(defvar THIS 61)
--> 61
Ready.
(defvar *this* 99)
--> 99
Ready.
(+ This this THIS *this*)
--> 226
Ready.
]

The value of a variable can be changed replaced during the
execution of a program. To do this JsLisp uses the command
[(setf <variable> <new-value>)].

[Assignment
(defvar x 21)
--> 21
Ready.
(* x x)
--> 441
Ready.
(setf x 9)
--> 9
Ready.
(* x x)
--> 81
Ready.
]

## Local variables

If a variable is needed only for a part of an expression and is
not needed later then it's better to use a "local variable".
These variables are normal variables with the difference that
they are limited in scope: they exist only for the amount of
time needed and they disappear after the computation is completed.

Local variables are introduced by the [(let (...) ...)] form:

[Local variables
(let ((r 12))
  (* r r pi))
--> 452.3893421169302
Ready.
r
WARNING: Undefined variable r
**ERROR**: ReferenceError: r is not defined
Ready.
]

As you see after the first computation the variable [r] was not
existing any more and attempting to showing its value produced
an error message.

Moreover a local variable can temporarely "hide" a global variable
with the same name as it's shown in the following:

[Hiding of a gloval variable
(defvar r 41)
--> 41
Ready.
(* r r pi)
--> 5281.017250684442
Ready.
(let ((r 12))
  (* r r pi))
--> 452.3893421169302
Ready.
(* r r pi)
--> 5281.017250684442
Ready.
]

Note that the [(let (...) ...)] form allows multiple local variables
to be declared at once:

[Multiple variables in a single (let ...) form
(let ((x 12)
      (y 33)
      (z 91))
  (* x y z))
--> 36036
Ready.
]

## Functions

JsLisp allows to define new functions by using [(defun ...)]:

[Defining new functions
(defun square-area (x)
  "Area of a square with given side"
  (* x x))
--> square-area
Ready.
(defun circle-area (r)
  "Area of a circle with given radius"
  (* r r pi))
--> circle-area
Ready.
(square-area 12)
--> 144
Ready.
(circle-area 12)
--> 452.3893421169302
Ready.
(defun rect-area (w h)
  "Area of a rectangle with given width and height"
  (* w h))
--> rect-area
Ready.
(rect-area 12 33)
--> 396
Ready.
]

The text that has been added right after the list of function arguments
is called "docstring" and helps describing what the function does
so that other programmers (or even the author after some time) can
be reminded what the function is about and what is the meaning of
the expected arguments.

## Display

In JsLisp there is a predefined [(display ...)] operator that can
show in the REPL window any intermediate result during a computation:

[Using (display ...) to show values duting a computation
(defun circle-area (radius)
  "Area of a circle"
  (* radius radius pi))
--> circle-area
Ready.
(defun circle-perimeter (radius)
  "Perimeter of a circle"
  (* 2 radius pi))
--> circle-perimeter
Ready.
(defun total-cost (radius material-cost rope-cost)
  "Computes total cost of a disc"
  (let ((area (circle-area radius))
        (perimeter (circle-perimeter radius)))
    (display (+ "Area: " area))
    (display (+ "Perimeter: " perimeter))
    (+ (* area material-cost)
       (* perimeter rope-cost))))
--> total-cost
Ready.
(total-cost 12 60 100)
=Area: 452.3893421169302
=Perimeter: 75.39822368615503
--> 34683.18289563131
Ready.
]
