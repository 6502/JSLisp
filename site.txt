@ About

JsLisp is a Lisp(1) Compiler(3) targeting Javascript(3)

In more detail...

# (1) A Lisp

JsLisp is a Lisp-2, similar to Common Lisp but is not Common Lisp

- Symbols are case sensitive.
- No cons cells. Lists are represented using Javascript lists.
- Lists are first-class objects. [push] is a regular function.
- No numeric tower. Numbers are double-precision floats (they provide
  53 bits of integer numeric accuracy).
- Dynamic and lexical variables.
- There can be both a function and a macro with the same name. Macro
  is used in explicit calls, function can be used for [funcall]/[apply].
- [NaN], [null], [undefined], [false], [0] are present with their
  Javascript value semantic.
- No [NIL]/[T]. Truth values are Javscript [true]/[false].
- [defmacro], [define-symbol-macro], [macrolet], [symbol-macrolet] are
  present mimicking Common Lisp semantic. Quasiquoting.
- Read macros.
- Interpolated string literals.
- No [loop] macro for now.

# (2) Compiler

JsLisp is a compile-only implementation and contains no interpreter,
[eval] is implemented by compiling and executing.  The core of the
compiler is hand-written Javascript, everything else is written in
JsLisp itself (boot.lisp).

Compiled functions are regular Javscript functions, callable from
Javascript code (with the exception of keyword arguments) and that
can call Javascript code.

Javascript inlining is possible and used heavily in the default
runtime library. Name mangling is necessary when converting JsLisp
symbol names to Javascript and vice versa [(mangle x)]/[(demangle x)].

Support for docstrings, parameter checking (done at compile time on
static calls), [&key]/[&optional]/[&rest] parameters.

# (3) Targeting Javascript

No attempt is made to create human-readable idiomatic Javascript,
generated code is not meant to be manually maintained.

Works with recent browsers and node.js.

Any Javascript functions or methods can be called from JsLisp code by
using the generic binding facility [bind-js-functions] and
[bind-js-methods].

@ License

I am not a lawyer and I just hope this is enough to leave me out
of jail... if you think it's not the please drop me a line.

The intention is that you can use JsLisp for whatever you want
(commercial or not) provided you just don't pretend you did something
that I did or that you blame me if you have any problem.

<<
<div style="border:solid 2px #000080; background-color:#EEEEFF;
            padding:12px; font-size:120%">
<p>Copyright (c) 2012 by Andrea Griffini</p>

<p>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:</p>

<ol>
<li style="margin-bottom:20px">
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</li>

<li style="font-weight:bold">
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</li></ol>
</div>
>>

@ Examples

The following sections are small examples of JsLisp interactive
sessions in the REPL. You can remove the output and copy/paste the
content in an interactive session to experiment with them.

Some of them are quite long and some require external resources like
graphics or data files that are on this server and that must be
available for the output to be computed.

Where not noted differently all those examples are meant to be run in
a reasonably recent web browser (Chrome, Safari, Firefox, IE9, Opera,
Android browser, Safari mobile).

@@ Fibonacci

This is a naive implementation of Fibonacci sequence computation.

The [(time ...)] macro measures the total time in milliseconds
that was required by the execution of contained forms and returns
this result.

[Fibonacci numbers (naive)
(defun fibo (n)
  "n-th Fibonacci number"
  (if (< n 2)
      1
      (+ (fibo (- n 1))
         (fibo (- n 2)))))
--> fibo
Ready.
(defun test-fibo (n)
  "Displays the first n Fibonacci numbers"
  (dotimes (i n)
    (display ~"(fibo {i}) --> {(fibo i)}")))
--> test-fibo
Ready.
(time (test-fibo 20))
=(fibo 0) --> 1
=(fibo 1) --> 1
=(fibo 2) --> 2
=(fibo 3) --> 3
=(fibo 4) --> 5
=(fibo 5) --> 8
=(fibo 6) --> 13
=(fibo 7) --> 21
=(fibo 8) --> 34
=(fibo 9) --> 55
=(fibo 10) --> 89
=(fibo 11) --> 144
=(fibo 12) --> 233
=(fibo 13) --> 377
=(fibo 14) --> 610
=(fibo 15) --> 987
=(fibo 16) --> 1597
=(fibo 17) --> 2584
=(fibo 18) --> 4181
=(fibo 19) --> 6765
--> 46
Ready.
]

@@ Memoization

For many functions the result is only dependent on parameter value
and for them it's possible to apply a technique called "memoization"
that simply stores away in a cache the result of computation for
each (or last n) values of the parameters. If the function takes
a long time to compute this may be a big win.

The following is a function that given a function returns a
memoized version of the function...

[Generic memoization
(defun memoize (f)
  "Returns a memoized version of function f"
  (let ((cache (js-object)))
    (lambda (&rest args)
      (let ((result (aref cache args)))
        (first (or result
                   (setf (aref cache args)
                         (list (apply f args)))))))))
--> memoize
Ready.
(setf #'fibo (memoize #'fibo))
--> #CODE
Ready.
(time (fibo 100))
--> 3
Ready.
(fibo 100)
--> 573147844013817200000
Ready.
]

@@ Recursive lambdas

If you need a recursive anonymous function the usual CL way
is to just use for example a [labels] form:

[Regular recursive anonymous function
(funcall (labels ((fibo (x)
                    (if (< x 2)
                        1
                        (+ (fibo (- x 1))
                           (fibo (- x 2))))))
           #'fibo)
         30)
--> 1346269
Ready.
]

A simpler (and less powerful) syntax for the same could be added with
a small macro form [rlambda]:

[(rlambda <args> <body>)
(defmacro rlambda (args &rest body)
  `(labels ((recurse ,args ,@body))
     #'recurse))
--> rlambda
Ready.
(funcall (rlambda (x)
           (if (< x 2)
               1
               (+ (recurse (- x 1))
                  (recurse (- x 2)))))
         30)
--> 1346269
Ready.
(funcall (rlambda (x)
           (* x (if (> x 1)
                    (recurse (1- x))
                    1)))
         10)
--> 3628800
]

I call these function anonymous even if indeed inside the function
they have a name ([fibo] in the [labels] form or [recurse] in the
[rlambda] macro forms) but this name disappears outside the function.

@ Give it a try!

JsLisp REPL can run in most recent web browsers.

This means there is no program to download and to install.

You can start a new fresh JsLisp session in a separate
window by clicking the following button.

<<
<input type=button value="Start JsLisp" onclick="window.open('jslisp.html', '_blank', 'width=800, height=800, left=100, top=100')"/>
>>

If you want to install JsLisp on your own computer unfortunately you
need to use a local web server because for security reasons Ajax
requests are not supported on local filesystem browsing.

@ JsLisp / CL

In this sections the differences between Common Lisp and JsLisp will
be explained in more detail. This is not meant to be a tutorial on
Lisp and a fairly decent understanding of Lisp is assumed.

## Main JsLisp philosophy

The main idea behind JsLisp was to create a Lisp system starting from
Javascript (instead of starting from IBM 704 instruction set) and
trying to become similar to Common Lisp up to the point where the
Javascript machine below would like to start complaining about that.

So basically the target of JsLisp was to become "as close as
reasonably possible to CL, but not closer".

Please also consider that current state of JsLisp is extremely flux
and subject to change. A few parts are departures from CL that I'm not
fully convinced about.

@@ No CAR / CDR

In JsLisp there is no [cons], no [car] and no [cdr]. I'm not joking.

OK. Please start breathing again. This is not a fundamental departure
from Lisp. Really.

There is nothing "essential" into using cons-cells except a conceptual
and formal minimality that represents a model neither our human brain
nor the today computer brain finds particularly simple.

Don't get me wrong. I think this was a fantastic smart choice for the
problem McCarthy was working on, but for both humans and most current
computers the array is a much more fundamental block than a linked
list.

JsLisp uses Javascript array objects to represent lists and lists are
mutable first-class objects. [push] in JsLisp can a be simple function
and doesn't need to be necessarily a macro.  Moreover [push] and [pop]
are defined to work like they naturally do in Javascript by adding and
removing elements at the end.

There are of course both [reverse] and [nreverse] available, but
they're much less needed than in Common Lisp because after pushing
things in a list they're already in the correct order.

Sharing is still possible and happens often with nested list
structures, but only at subtree level and not at the tail level.
Still for example is not safe to assume that quasiquoting will return
a fresh unshared tree structure.

For representing code and in many cases in which sharing is not
essential this approach is much more efficient than using cons cells
to build lists and it's also the way the underlying "hardware" works
(Javascript).

Creating cells-based lists is of course possible for example using
two-elements arrays and can be a sensible choice if the tail-sharing
possibilities are playing an important role for your problem.

@@ Lisp-3

In JsLisp there are three main values for a symbol: the value, the
function and the macro. In JsLisp is therefore possible to have both a
function and a macro sharing the same name.

The macro is used (if present) every time a static call form is
compiled, while the function is used instead every time a [(function
...)] form is used to pass or store away the function.

Like in Common Lisp the call [(symbol-function x)] returns the global
function associated with the symbol [x] (not considering lexical
function bindings) and [(function x)] abbreviated as usual [#'x]
returns the function binding of the unevaluated symbol [x] those
introduced in a lexical scope.

In a similar way the function [(symbol-macro x)] returns the global
macro associated to the symbol [x] (not considering lexical macros
established by [macrolet]). The current macro binding associated
with the unevaluated symbol [x] is accessible with [(macro x)] and
there is no reader macro for this very infrequent need.

Something that is used quite often in [boot.lisp] is the macro
 [defmacro/f] that allows defining at the same time a macro and a
 function and that but that can be used however only for functions
 with a fixed number of arguments.

[defmacro/f
(defmacro/f square (x)
  (let ((y (gensym)))
    `(let ((,y ,x))
       (* ,y ,y))))
--> square
Ready.
(square 12)
--> 144
Ready.
(macroexpand-1 '(square (+ x y)))
--> (let ((G:12 (+ x y))) (* G:12 G:12))
Ready.
(map #'square (range 10))
--> (0 1 4 9 16 25 36 49 64 81)
Ready.
]

@@ Numbers

JsLisp doesn't provide the Common Lisp numeric tower.

Numbers are just Javascript numbers, i.e. double-precision floating
point values that ensure unit-accurate integer computations "only" up
to [-/+ 9,007,199,254,740,992] (2 to the 53rd power, more than
nine millions of billions).

Also all math functions are simple wrappers of Javascript math
functions and therefore the rules about [NaN] and [null] results
of computations are dictated down there (e.g. [(/ 0) -> null]
but [(log -1) -> NaN]).

@@ Reader

JsLisp reader allows customization like Common Lisp, but using a
different approach.

Parse functions take as only argument a "source" that is a callable
object (closure) that accepts a single integer argument; when passed
[0] it returns the current character in the stream and when passed [1]
advances to next character (still returning the old character).

To read from a string there is a predefined [(reader-function s)]
that returns a suitable closure for scanning the string [s].

Reader customization can be done mainly in two ways:

### 1) Defining a reader function for a character

Consider a classical example of customizing the reader so
that lambda forms can be specified more succintly:

+--------------------+--------------------------+
|        this        |  is interpreted as this  |
+--------------------+--------------------------+
| [{x -> (* x 2)}]   | [(lambda (x) (* x 2))]   |
| [{x y -> (+ x y)}] | [(lambda (x y) (+ x y))] |
| [{+ x 1}]          | [(lambda (x) (+ x 1))]   |
+--------------------+--------------------------+

If an application is using a lot of anonymous functions this
transformation could lead to a subjectively more readable code.

[Reader customization example 1
(setf (reader "{")
      (lambda (src)
        (funcall src 1)
        (let ((form (parse-delimited-list src "}")))
          (let ((i (index '-> form)))
            (if (>= i 0)
                `(lambda ,(slice form 0 i)
                   ,@(slice form (1+ i)))
                `(lambda (x) ,form))))))
--> #CODE
Ready.
(parse-value "{+ x 1}")
--> (lambda (x) (+ x 1))
Ready.
(parse-value "{x y -> (* x y)}")
--> (lambda (x y) (* x y))
Ready.
(map {* x x} (range 10))
--> (0 1 4 9 16 25 36 49 64 81)
Ready.
]

### 2) Redefining (wrapping) the [parse-value] predefined function

The other option is replacing the [parse-value] function that is used
every time JsLisp needs to read from a character source.

For example consider the customization of the reader that handles
symbols containing dots so that for example [document.write] is
interpreted as [(. document write)] allowing a more "usual" access
to DOM property values.

[Redefining parse-value
(setf #'parse-value
      (let ((oldf #'parse-value))
        (lambda (src)
          (let ((x (funcall oldf src)))
            (when (and (symbolp x)
                       (find "." (symbol-name x)))
              (setf x `(. ,@(map #'intern
                                 (split (symbol-name x) ".")))))
            x))))
--> #CODE
Ready.
document.body.style.padding
--> "0px"
Ready.
(parse-value "document.body.style.padding")
--> (. document body style padding)
Ready.
]
