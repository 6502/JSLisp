(defun compile (x ctx)
  (cond
   ((symbol? x)
    (push `(load ,x) ctx.code))
   ((list? x)
    (cond
     ((= (first x) 'quote)
      (push `(const ,(second x)) ctx.code))
     ((= (first x) 'progn)
      (if (= (length x) 2)
          (compile (second x) ctx)
          (progn
            (compile (second x) ctx)
            (dolist (y (slice x 2))
              (push `(pop) ctx.code)
              (compile y ctx)))))
     ((= (first x) 'setq)
      (compile (third x) ctx)
      (push `(store ,(second x)) ctx.code))
     ((= (first x) 'if)
      (let ((else (incf ctx.labels))
            (endif (incf ctx.labels)))
       (compile (second x) ctx)
       (push `(jfalsep ,else) ctx.code)
       (compile (third x) ctx)
       (push `(jmp ,endif) ctx.code)
       (push else ctx.code)
       (compile (fourth x) ctx)
       (push endif ctx.code)))
     ((= (first x) 'lambda)
      (let ((nctx #((code (list))
                    (labels 0)
                    (parent ctx))))
        (push `(args ,(reverse (second x))) nctx.code)
        (dolist (y (slice x 2))
          (compile y nctx))
        (push `(ret) nctx.code)
        (push `(const ,nctx.code) ctx.code)))
     (true
      (if (symbol? (first x))
          (push `(load ,(intern (+ "f/" (symbol-name (first x))))) ctx.code)
          (compile (first x) ctx))
      (dolist (y (slice x 1))
        (compile y ctx))
      (push `(call ,(1- (length x))) ctx.code))))
   ((push `(const ,x) ctx.code))))

(defun step (rctx)
  (let ((op (aref rctx.code (1- (incf rctx.ip)))))
    (cond
      ((number? op)
       rctx)
      ((= (first op) 'const)
       (push (second op) rctx.stack)
       rctx)
      ((= (first op) 'load)
       (push (aref rctx.env (second op) 0) rctx.stack)
       rctx)
      ((= (first op) 'store)
       (setf (aref rctx.env (second op) 0) (last rctx.stack))
       rctx)
      ((= (first op) 'pop)
       (pop rctx.stack)
       rctx)
      ((= (first op) 'jmp)
       (setf rctx.ip (1+ (index (second op) rctx.code)))
       rctx)
      ((= (first op) 'jfalsep)
       (unless (pop rctx.stack)
         (setf rctx.ip (1+ (index (second op) rctx.code))))
       rctx)
      ((= (first op) 'call)
       (let ((frame (splice rctx.stack (- (length rctx.stack) (1+ (second op))))))
         (if (callable? (first frame))
             (progn
               (push (apply (first frame) (slice frame 1)) rctx.stack)
               rctx)
             #((parent rctx)
               (stack (slice frame 1))
               (ip 0)
               (code (first frame))
               (env (bare-object rctx.env))))))
      ((= (first op) 'ret)
       (push (pop rctx.stack) rctx.parent.stack)
       rctx.parent)
      ((= (first op) 'args)
       (dolist (s (second op))
         (setf (aref rctx.env s) (list (pop rctx.stack))))
       rctx)
      (true (error ~"Unknown instruction {op}")))))

(let ((ctx #((code (list))
             (labels 0))))
  (compile '((lambda (f/fibo)
               (setq f/fibo (lambda (x)
                              (if (< x 2)
                                  1
                                  (+ (fibo (- x 1))
                                     (fibo (- x 2))))))
               (fibo 20)) 0)
           ctx)
  (dolist (c ctx.code)
    (display (str-value c)))
  (do ((rctx #((code ctx.code)
               (stack (list))
               (ip 0)
               (env (let ((env (bare-object null)))
                      (setf (aref env 'f/+) (list (lambda (a b) (+ a b))))
                      (setf (aref env 'f/-) (list (lambda (a b) (- a b))))
                      (setf (aref env 'f/<) (list (lambda (a b) (< a b))))
                      env)))))
    ((>= rctx.ip (length rctx.code))
     (display (str-value rctx.stack)))
    ;;(display ~"{rctx.ip} : {(str-value (aref rctx.code rctx.ip))}")
    (setf rctx (step rctx))
    ;;(display ~"  stack:{(str-value rctx.stack)} env:{(str-value rctx.env)}")
    ))

