(defvar mode
  #((parmatch (lambda (lines row col)
                (block parmatch
                  (let** ((r 0)
                          (c -1)
                          (last null)
                          (current null)
                          (#'next ()
                                  (setf last current)
                                  (when (> (incf c) (length (aref lines r).text))
                                    (setf c 0) (incf r))
                                  (setf current
                                        (if (or (> r row)
                                                (and (= r row) (>= c col)))
                                            undefined
                                            (or (aref lines r "text" c) "\n"))))
                          (close (aref lines row "text" (1- col)))
                          (open (aref "{[(" (index close "}])")))
                          (stack (list)))
                    (next)
                    (do ()
                        ((or (undefined? current)
                             (or (> r row)
                                 (and (= r row) (>= c (1- col)))))
                         (last stack))
                      (cond
                       ((= current "\"")
                        (next)
                        (do ()
                            ((or (undefined? current)
                                 (= current "\n")
                                 (= current "\""))
                             (when (undefined? current)
                               (return-from parmatch null))
                             (next))
                          (when (= current "\\")
                            (next))
                          (next)))
                       ((and (= current "/") (= last "/"))
                        (do ()
                            ((or (undefined? current)
                                 (= current "\n")))
                          (next))
                        (when (undefined? current)
                          (return-from parmatch null)))
                       ((and (= current "*") (= last "/"))
                        (next)
                        (do ()
                            ((or (undefined? current)
                                 (and (= current "/") (= last "*")))
                             (next))
                          (next))
                        (when (undefined? current)
                          (return-from parmatch null)))
                       ((= current open)
                        (push (list r c) stack)
                        (next))
                       ((= current close)
                        (pop stack)
                        (next))
                       (true (next))))))))
    (compute-end-context (lambda (line)
                           (do ((ec (copy line.start-context))
                                (text (rstrip line.text))
                                (i 0)
                                (sections (list)))
                               ((>= i (length text))
                                (unless (= (last text) "\\")
                                  (setf ec.preproc false))
                                (when (> (length line.text) (length text))
                                  (push (new-section (length text) (length line.text)
                                                     #((background-color "#C0FFC0")))
                                        sections))
                                (setf line.sections sections)
                                ec)
                             (cond
                              (ec.mlcomment
                               (let ((i0 i))
                                 (do () ((or (= i (length text))
                                             (= (slice text i (+ i 2)) "*/")))
                                   (incf i))
                                 (when (= (slice text i (+ i 2)) "*/")
                                   (setf ec.mlcomment false)
                                   (incf i 2))
                                 (push (new-section i0 i #((color "#888888"))) sections)))
                              (ec.preproc
                               (push (new-section i (length text) #((color "#880088"))) sections)
                               (setf i (length text)))
                              ((= (slice text i (+ i 2)) "/*")
                               (setf ec.mlcomment true))
                              ((= (aref text i) "#")
                               (setf ec.preproc true))
                              ((or (and (= (aref text i) ".") (<= "0" (aref text (1+ i)) "9"))
                                   (<= "0" (aref text i) "9"))
                               (let ((i0 i))
                                 (if (find (slice text i (+ i 2)) '("0x" "0X"))
                                     (progn
                                       (incf i 2)
                                       (do () ((or (= i (length text))
                                                   (not (find (aref text i) "0123456789abcdefABCDEF")))
                                               (push (new-section i0 i #((color "#884400"))) sections))
                                         (incf i)))
                                     (progn
                                       (do () ((or (= i (length text))
                                                   (< (aref text i) "0")
                                                   (> (aref text i) "9")))
                                         (incf i))
                                       (when (= (aref text i) ".")
                                         (incf i)
                                         (do () ((or (= i (length text))
                                                     (< (aref text i) "0")
                                                     (> (aref text i) "9")))
                                           (incf i)))
                                       (when (find (aref text i) "eE")
                                         (incf i)
                                         (when (find (aref text i) "+-")
                                           (incf i))
                                         (do () ((or (= i (length text))
                                                     (< (aref text i) "0")
                                                     (> (aref text i) "9")))
                                           (incf i)))
                                       (push (new-section i0 i #((color "#FF4444"))) sections)))))
                              ((= (aref text i) "\"")
                               (let ((i0 i))
                                 (incf i)
                                 (do () ((or (>= i (length text))
                                             (= (aref text i) "\""))
                                         (when (< i (length text))
                                           (incf i))
                                         (push (new-section i0 i #((color "#008800"))) sections))
                                   (if (= (aref text i) "\\")
                                       (incf i 2)
                                       (incf i)))))
                              ((= (slice text i (+ i 2)) "//")
                               (push (new-section i (length text) #((color "#888888"))) sections)
                               (setf i (length text)))
                              (((regexp "[_a-zA-Z]").exec (aref text i))
                               (let ((i0 i))
                                 (do ()
                                     ((or (= i (length text))
                                          (not ((regexp "[_a-zA-Z0-9]").exec (aref text i))))
                                      (when (find (slice text i0 i)
                                                  '("if" "else" "do" "switch" "goto"
                                                    "while" "for" "return" "break" "case"
                                                    "struct" "union" "typedef"
                                                    "void" "int" "double" "char" "const"
                                                    "float" "unsigned"
                                                    "extern" "static" "inline"))
                                        (push (new-section i0 i #((bold true)
                                                                  (color "#0000CC")))
                                              sections)))
                                   (incf i))))
                              (true
                               (incf i))))))
    (autoindent (lambda (lines row)
                  (when (> row 0)
                    (let ((line (aref lines (1- row)))
                          (newline (aref lines row)))
                      (let ((indent (length (first ((regexp "^ *").exec line.text)))))
                        (when (> indent 0)
                          (setf newline.text
                                (+ (slice line.text 0 indent)
                                   newline.text)))
                        indent)))))))

(export mode)
