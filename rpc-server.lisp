;;
;; Server side, an http-server able to serve static files
;; and to handle `/process` http requests.
;; Serving static files is useful because of Same Origin Policy
;;

(defvar *typemap* #((".html" "text/html")
                    (".css"  "text/css")
                    (".js"   "text/javascript")
                    (".jpg"  "image/jpeg")
                    (".png"  "image/png")
                    (".pdf"  "application/pdf")
                    (".txt"  "text/plain")
                    (".gz"   "application/x-gzip")
                    (".zip"  "application/zip")))

(defun process-request (req)
  (error ~"Unknown request {req.%class}"))

(defun process (url parms data response)
  (display ~"Processing url={url}, parms={parms}, data={data}")
  (when (and (= parms "") (not (null? data)))
    (setf parms data))
  (let ((content (try (cond
                        ((= url "/process")
                         (uri-encode
                          (json*
                           (process-request (json-parse* (uri-decode parms))))))
                        (((regexp "^/process-as\\.[a-z0-9]+$").exec url)
                         (process-request (json-parse* (uri-decode parms))))
                        (true (try (get-file (+ "." url) null)
                                   (progn
                                     (response.writeHead 404)
                                     (response.end "File not found")
                                     (return-from process)))))
                      (progn
                        (display ~"ERROR: {*exception*}")
                        (response.writeHead 500)
                        (response.end "Internal error")
                        (return-from process))))
        (ctype (or (aref *typemap* ((regexp "\\.[a-z0-9]*$").exec url))
                   "application/octect-stream")))
    (response.writeHead 200 #((Content-Type ctype)))
    (response.end content)))

(defun multipart-form-data (buffers boundary)
  (let* ((buf ((node:require "buffer").Buffer.concat buffers))
         (bd (map #'char-code (+ "\r\n--" boundary)))
         (bd0 (map #'char-code (+ "--" boundary "\r\n")))
         (tlen (length buf))
         (cp0 null)
         (cp 0)
         (limit (- tlen (length bd)))
         (result #()))
    (labels ((match (b)
               (dotimes (i (length b))
                 (unless (= (aref buf (+ cp i))
                            (aref b i))
                   (return-from match false)))
               true))
      (when (match bd0)
        (incf cp (length bd0))
        (setf cp0 cp))
      (do ()
          ((> cp (- tlen (length bd))))
        (if (and (match bd)
                 (or (and (= (aref buf (+ cp (length bd))) 13)
                          (= (aref buf (+ cp (length bd) 1))) 10)
                     (and (= (aref buf (+ cp (length bd))) 45)
                          (= (aref buf (+ cp (length bd) 1))) 45)))
            (progn
              (unless (null? cp0)
                (let ((filename null)
                      (name null))
                  (do ()
                      ((or (= cp0 cp)
                           (and (= (aref buf cp0) 13)
                                (= (aref buf (1+ cp0)) 10)))
                         (incf cp0 2))
                    (do ((hs cp0))
                        ((or (= cp0 cp)
                             (= (aref buf cp0) 13))
                           (let* ((hline (+ "" (slice buf hs cp0)))
                                  (nm ((regexp " name=\"([^\"]+)\"").exec hline))
                                  (fm ((regexp " filename=\"([^\"]+)\"").exec hline)))
                             (when nm (setf name (second nm)))
                             (when fm (setf filename (second fm))))
                           (incf cp0 2))
                      (incf cp0)))
                  (if filename
                      (let ((dstfile (+ ((node:require "os").tmpDir)
                                        "/"
                                        (join (map (lambda (x)
                                                     (char (+ 65 (random-int 26))))
                                                   (range 8))
                                              "")
                                        ".upload.tmp")))
                        ((node:require "fs").writeFileSync dstfile (slice buf cp0 cp))
                        (setf (aref result name) (list dstfile filename)))
                      (setf (aref result name) (+ "" (slice buf cp0 cp))))))
              (if (= (aref buf (+ cp (length bd))) 45)
                  (setf cp tlen)
                  (incf cp (+ (length bd) 2)))
              (setf cp0 cp))
            (incf cp))))
    result))

(defun rpc-handler (request response)
  (let ((url (. request url))
        (parms null))
    (when (find "?" url)
      (let ((i (index "?" url)))
        (setf parms (slice url (1+ i)))
        (setf url (slice url 0 i))))
    (if (= request.method "POST")
        (let ((data (list)))
          (request.on "data"
                      (lambda (chunk)
                        (push chunk data)))
          (request.on "end"
                      (lambda ()
                        (let ((bdcheck ((regexp "multipart.*boundary=(.*)").exec
                                        request.headers."content-type")))
                          (if bdcheck
                              (progn
                                (setf parms (multipart-form-data data (second bdcheck)))
                                (display ~"multipart/form-data parms -> {(json parms)}")
                                (setf data null))
                              (setf data (join data "")))
                          (process url parms data response)))))
        (process url parms null response))))

(defun start-server (address port)
  (let* ((http (node:require "http"))
         (server (http.createServer #'rpc-handler)))
    (server.listen port address)))

(setf (symbol-macro 'rpc:defun)
      (lambda (name args &rest body)
        (setf name (module-symbol name))
        (let ((fields (filter (lambda (x) (/= x '&optional))
                              (map (lambda (f)
                                     (if (list? f) (first f) f))
                                   args))))
          `(progn
             (defun ,name ,args ,@body)
             (defobject ,#"{name}-req" ,fields)
             (defmethod process-request (req) (,#"{name}-req?" req)
                        (,name ,@(map (lambda (f)
                                        `(. req ,f))
                                      fields)))))))

(export start-server)
