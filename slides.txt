*1 JsLisp
= JsLisp
A Lisp compiler targeting Javascript

*2 A Lisp compiler targeting Javascript
{JsLisp is}

- A Lisp
- Compiler
- Targeting Javascript

*3 A Lisp
{A Lisp}

Lisp is a family of dialects, the two most
known being Common Lisp and Scheme.

JsLisp is close to Common Lisp
but it's not Common Lisp.

*3.1 Common Lisp similarities
{JsLisp and Common Lisp similarities}

- A Lisp-2 (actually a Lisp-3)
- Macros and reader macros
- Macro hygiene is not forced
- Looping constructs [do], [dotimes], [dolist] ...
- [tagbody/go], [throw/catch], [unwind-protect]

*3.1.1 Reading and compiling
{Reading and compiling}

In a Lisp system the process of translating
source code characters to code consists in
two separate steps: reading and compiling:

[chars] ==> [A.S.T.] ==> [code]

Both the steps can be customized with
[reader macros] or [macros].

*3.1.2 Example of a reader macro
{Small reader macro example}

[[
(setf (reader "[")
      (lambda (src)
        (next-char src)
        `(lambda (x)
           ,(parse-delimited-value src "]"))))
]]

After which:

[[
(map [* x x] (range 10))
--> (0 1 4 9 16 25 36 49 64 81)
]]

*3.2 Common Lisp differences
{JsLisp and Common Lisp differences}

- No [cons] cells, lists are Javascript arrays
- No numeric tower (only [double-float]s)
- No [T]/[NIL]
- [true], [false], [null], [undefined], [NaN]
- A namespace partitioning system similar
  (but not identical) to CL packages.
- [Lisp-3]: a function and a macro can have
  the same name. [(funcall #'x ...)] {may be}
  logically different from [(x ...)]. Rarely is.

*3.2.1 An example of macro/function diversion
{An example where semantic is not the same}

[(< (f) (g) (h))] is short-circuiting and
call to [(h)] may be skipped.

[(funcall #'< (f) (g) (h))] obviously
always calls [(f)], [(g)] and [(h)].

[(< (f))] returns [true] and doesn't call [f]!

Normally macro/function dual implementation
only exists for performance reasons. JsLisp has
no concept of CL compiler-macros, only macros.

*4 Compiler
{Compiler}

JsLisp is a compiler-only implementation, there
is no Lisp interpreter

- JsLisp functions are Javascript functions
- Thanks to JIT speed is quite good
- Semantic checks at compile time
- There is a treeshaker/minifier that provides
  source code IP protection

*4.1 Semantic checks
{Semantic checks}

JsLisp compiler provides some semantic check
at compile time:

- References to undefined variables
- References to undefined functions
- Bad parameter count in static function calls
- Bad keyword paramters in static function calls

*5 Targeting Javascript
{Targeting Javascript}

- Code is standard Javascript.
- Runs in recent desktop browsers.
- Runs in node.js.
- Runs in HTML5 smartphones/tablets.
- Using node.js allows a single seamless
  environment for both client ans server
  sides of a solution.
