(defun spawn (command arguments stdout stderr exit)
  "Starts a new process executing [command] passing specified [arguments],
   calling [stdout]/[stderr] functions for any output produced and
   calling [exit] function with the return code."
  (let* ((spawn (js-code "require('child_process').spawn"))
         (cmd (funcall spawn command arguments)))
    (cmd.stdout.on "data" stdout)
    (cmd.stderr.on "data" stderr)
    (cmd.on "exit" exit)
    cmd))

(defun main ()
  (let ((output "")
        (sources #())
        (targets #()))
    (spawn "find" (list "." "-name" "*.lisp")
           (lambda (out)
             (incf output (out.toString)))
           (lambda (err)
             (error ~"STDERR: {(err.toString)}"))
           (lambda (code)
             (unless (= code 0)
               (error ~"Invalid return code {code}"))
             (let ((files (map (lambda (x) (slice x 2))
                               (filter #'length (split output "\n")))))
               (dolist (f files)
                 (display ~"Analyzing {f}")
                 ;; Analysis is performed by a mixture of text search
                 ;; and parsing because of the problem of user-defined
                 ;; reader macros. It's assumed that no reader macro is
                 ;; used in an import form and that there's no space
                 ;; between the open parenthesis and "import".
                 (let ((srctext (get-file f)))
                   (do ((i0 -1 i)
                        (i (index "(import " srctext) (index "(import " srctext (1+ i0))))
                       ((= i -1))
                     (labels ((add-dep (target source)
                                (push target (or (aref targets source)
                                                 (setf (aref targets source) (list))))
                                (push source (or (aref sources target)
                                                 (setf (aref sources target) (list))))))
                       (try (let ((x (read (slice srctext i))))
                              (cond
                                ;; (import <module> [as <nick>])
                                ((and (or (= (length x) 2)
                                          (and (= (length x) 4) (= (third x) 'as)))
                                      (symbol? (second x)))
                                 (let ((mname (+ (symbol-name (second x)) ".lisp")))
                                   (when (find mname files)
                                     (add-dep f mname))))
                                ;; (import ... from <module> [as <nick>])
                                ((and (or (and (= (length x) 4)
                                               (= (aref x 2) 'from)
                                               (symbol? (aref x 3)))
                                          (and (= (length x) 6)
                                               (= (aref x 2) 'from)
                                               (= (aref x 4) 'as)
                                               (symbol? (aref x 3)))))
                                 (let ((mname (+ (symbol-name (aref x 3)) ".lisp")))
                                   (when (find mname files)
                                     (add-dep f mname))))))
                            (display ~"parse error ignored"))))))
               (display "\nGenerating Makefile")
               (let ((res ""))
                 (dolist (target (keys sources))
                   (let ((base (slice target 0 -5)))
                     (incf res ~"{base}.html:")
                     (dolist (source (aref sources target))
                       (incf res ~" {source}"))
                     (incf res ~"\n\tnode jslisp.js deploy-html.lisp {target} > {base}.html\n\n")))
                 (js-code "require('fs').writeFile('Makefile',d$$res)")))))))

(main)