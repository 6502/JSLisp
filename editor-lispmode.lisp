(defvar mode #())

(import (new-section) from editor)

(setf mode.styles #((extra-spaces #((underline "#FF0000")))
                    (string-literal #((color "#008800")))
                    (comment #((color "#888888")))
                    (number-literal #((color "#CC4444")))
                    (function #((color "#008888")))
                    (macro #((color "#0000FF")))
                    (keyword #((color "#880088")))))

(setf mode.nonword "[^-a-zA-Z0-9_+*/!$%^&=<>]")

(setf mode.macros #())
(setf mode.body-macros #())
(setf mode.functions #())
(setf mode.vars #())
(setf mode.current-module "")

(setf mode.words
      (lambda ()
        (append (keys mode.macros)
                (keys mode.functions)
                (keys mode.vars))))

(setf mode.parmatch
      (lambda (lines row col)
        (block parmatch
          (let** ((r 0)
                  (c -1)
                  (last null)
                  (current null)
                  (#'next ()
                          (setf last current)
                          (when (> (incf c) (length (aref lines r).text))
                            (setf c 0) (incf r))
                          (setf current
                                (if (or (> r row)
                                        (and (= r row) (>= c col)))
                                    undefined
                                    (or (aref lines r "text" c) "\n"))))
                  (close (aref lines row "text" (1- col)))
                  (open (aref "{[(" (index close "}])")))
                  (stack (list)))
            (next)
            (do ()
                ((or (undefined? current)
                     (or (> r row)
                         (and (= r row) (>= c (1- col)))))
                   (last stack))
              (cond
                ((= current "\"")
                 (next)
                 (do ()
                     ((or (undefined? current)
                          (= current "\""))
                        (when (undefined? current)
                          (return-from parmatch null))
                        (next))
                   (when (= current "\\")
                     (next))
                   (next)))
                ((= current ";")
                 (do ()
                     ((or (undefined? current)
                          (= current "\n")))
                   (next))
                 (when (undefined? current)
                   (return-from parmatch null)))
                ((and (= current "|") (= last "#"))
                 (next)
                 (do ()
                     ((or (undefined? current)
                          (and (= current "#") (= last "|")))
                        (next))
                   (next))
                 (when (undefined? current)
                   (return-from parmatch null)))
                ((= current open)
                 (push (list r c) stack)
                 (next))
                ((= current close)
                 (pop stack)
                 (next))
                (true (next))))))))

(setf mode.inspect-ilisp
      (lambda (ilisp &optional on-completion)
        (ilisp.send "quiet-lisp"
                    "(let** ((res (list))
                             (#'full-demangle (n)
                               (let ((ix (index \"$$\" n)))
                                 (+ (demangle (+ \"$$\" (slice n 1 ix)))
                                    \":\"
                                    (demangle (slice n ix))))))
                       (dolist (name (keys (js-code \"window\")))
                         (when ((regexp \"^s([$][0-9]+_|[a-zA-Z0-9_])*[$][$].*\").exec name)
                           (let ((x (aref (js-code \"window\") name)))
                             (when (symbol? x)
                               (when (symbol-macro x)
                                 (push (list \"m\"
                                             (full-demangle name)
                                             (str-value (symbol-macro x).arglist)
                                             (symbol-macro x).documentation) res))
                               (when (symbol-function x)
                                 (push (list \"f\"
                                             (full-demangle name)
                                             (str-value (symbol-function x).arglist)
                                             (symbol-function x).documentation) res))))))
                       (dolist (k (keys *symbol-aliases*))
                         (let ((s (aref *symbol-aliases* k)))
                           (when (symbol? s)
                             (let ((f (symbol-function s)))
                               (when f (push (list \"f\"
                                                   (+ \":\" (slice k 1))
                                                   (str-value f.arglist)
                                                   f.documentation)
                                             res)))
                             (let ((f (symbol-macro s)))
                               (when f (push (list \"m\"
                                                   (+ \":\" (slice k 1))
                                                   (str-value f.arglist)
                                                   f.documentation)
                                             res))))))
                       (list *current-module* res))"
                    (lambda (result)
                      (setf mode.body-macros #())
                      (setf mode.macros #())
                      (setf mode.functions #())
                      (setf mode.vars #())
                      (setf result (first (json-parse result)))
                      (setf mode.current-module (first result))
                      (dolist (x (second result))
                        (case (first x)
                          ("m"
                           (setf (aref mode.macros (second x)) (slice x 2))
                           (when (= (slice (or (aref x 2) "") -6) " body)")
                             (setf (aref mode.body-macros (second x)) 1)))
                          ("f"
                           (setf (aref mode.functions (second x)) (slice x 2)))
                          ("d"
                           (setf (aref mode.vars (second x)) 1))))
                      (when on-completion
                        (funcall on-completion))))))

(setf mode.compute-end-context
      (lambda (line)
        (macrolet ((style (i0 i1 x)
                     `(push (new-section ,i0 ,i1 (. mode styles ,x)) sections)))
          (do ((ec (let ((ec (copy line.start-context)))
                     (setf ec.parens (copy line.start-context.parens))
                     ec))
               (text (rstrip line.text))
               (i 0)
               (sections (list)))
              ((>= i (length text))
                 (when (> (length line.text) (length text))
                   (style (length text) (length line.text) extra-spaces))
                 (setf line.sections sections)
                 ec)
            (cond
              (ec.string
               (let ((i0 i))
                 (do () ((or (= i (length text))
                             (= (aref text i) "\"")))
                   (when (and (< i (1- (length text)))
                              (= (aref text i) "\\"))
                     (incf i))
                   (incf i))
                 (when (= (aref text i) "\"")
                   (setf ec.string false)
                   (when ec.parens (pop ec.parens))
                   (incf i))
                 (style i0 i string-literal)))
              (ec.mlcomment
               (let ((i0 i))
                 (do () ((or (= i (length text))
                             (= (slice text i (+ i 2)) "|#")))
                   (incf i))
                 (when (= (slice text i (+ i 2)) "|#")
                   (setf ec.mlcomment false)
                   (when ec.parens (pop ec.parens))
                   (incf i 2))
                 (style i0 i comment)))
              ((= (slice text i (+ i 2)) "#|")
               (push (+ i 3) (or ec.parens (setf ec.parens (list))))
               (setf ec.mlcomment true))
              ((or (and (= (aref text i) ".") (<= "0" (aref text (1+ i)) "9"))
                   (and (= (aref text i) "-") (<= "0" (aref text (1+ i)) "9"))
                   (<= "0" (aref text i) "9"))
               (let ((i0 i))
                 (when (= (aref text i) "-")
                   (incf i))
                 (do () ((or (= i (length text))
                             (< (aref text i) "0")
                             (> (aref text i) "9")))
                   (incf i))
                 (when (= (aref text i) ".")
                   (incf i)
                   (do () ((or (= i (length text))
                               (< (aref text i) "0")
                               (> (aref text i) "9")))
                     (incf i)))
                 (when (find (aref text i) "eE")
                   (incf i)
                   (when (find (aref text i) "+-")
                     (incf i))
                   (do () ((or (= i (length text))
                               (< (aref text i) "0")
                               (> (aref text i) "9")))
                     (incf i)))
                 (if (and (< i (length text))
                          (/= (aref text i) " ")
                          (not (find (aref text i) *stopchars*)))
                     (do ()
                         ((or (= i (length text))
                              (= (aref text i) " ")
                              (find (aref text i) *stopchars*)))
                       (incf i))
                     (style i0 i number-literal))))
              ((= (aref text i) "(")
               (do ((j (1+ i) (1+ j)))
                   ((or (>= j (length text))
                        (= (aref text j) " ")
                        (= (aref text j) "(")
                        (= (aref text j) ")"))
                      (push (cond
                              ((>= j (length text))
                               (+ i 2))
                              ((= (slice text (1+ i) (+ i 3)) "#'")
                               (+ i 2))
                              ((= (aref text j) " ")
                               (let ((name (slice text (1+ i) j)))
                                 (if (or (aref mode.body-macros (+ ":" name))
                                         (aref mode.body-macros (+ mode.current-module
                                                                   ":"
                                                                   name)))
                                     (+ i 2)
                                     (+ j 1))))
                              (true j))
                            (or ec.parens (setf ec.parens (list))))
                      (cond
                        ((or (aref mode.functions (+ ":" (slice text (1+ i) j)))
                             (aref mode.functions (+ mode.current-module
                                                     ":"
                                                     (slice text (1+ i) j))))
                         (style (1+ i) j function)
                         (setf i (1- j)))
                        ((or (aref mode.macros (+ ":" (slice text (1+ i) j)))
                             (aref mode.macros (+ mode.current-module
                                                  ":"
                                                  (slice text (1+ i) j))))
                         (style (1+ i) j macro)
                         (setf i (1- j))))))
               (incf i))
              ((= (aref text i) ")")
               (pop (or ec.parens (setf ec.parens (list))))
               (incf i))
              ((= (aref text i) "\"")
               (setf ec.string true)
               (let ((i0 i))
                 (incf i)
                 (push i (or ec.parens (setf ec.parens (list))))
                 (do () ((or (= i (length text))
                             (= (aref text i) "\"")))
                   (when (and (< i (1- (length text)))
                              (= (aref text i) "\\"))
                     (incf i))
                   (incf i))
                 (when (= (aref text i) "\"")
                   (setf ec.string false)
                   (when ec.parens (pop ec.parens))
                   (incf i))
                 (style i0 i string-literal)))
              ((= (aref text i) ";")
               (style i (length text) comment)
               (setf i (length text)))
              ((= (aref text i) " ")
               (do () ((or (= i (length text))
                           (/= (aref text i) " ")))
                 (incf i)))
              (true
               (let ((i0 i))
                 (incf i)
                 (do ()
                     ((or (>= i (length text))
                          (= (aref text i) " ")
                          (find (aref text i) *stopchars*)))
                   (incf i))
                 (when (= (aref text (1- i)) ":")
                   (style i0 i keyword)))))))))

(setf mode.autoindent
      (lambda (lines row)
        (when (> row 0)
          (let ((line (aref lines (1- row)))
                (newline (aref lines row)))
            (let ((indent (last (or (mode.compute-end-context line).parens
                                    (list 0)))))
              (setf newline.text
                    (+ (str-repeat " " indent)
                       (lstrip newline.text)))
              indent)))))

(setf mode.toplevel-sexpr
      (lambda (lines row)
        (let ((r0 row)
              (r1 (1+ row)))
          (do () ((or (= r0 0)
                      (= (length (or (aref lines r0).start-context.parens
                                     (list)))
                         0)))
            (decf r0))
          (do () ((or (= r1 (length lines))
                      (= (length (or (aref lines r1).start-context.parens
                                     (list)))
                         0)))
            (incf r1))
          (join (map (get .text) (slice lines r0 r1)) "\n"))))

(export mode)
