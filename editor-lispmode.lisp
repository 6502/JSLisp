(defvar mode #())

(import (new-section) from editor)

(setf mode.parmatch
      (lambda (lines row col)
        (block parmatch
          (let** ((r 0)
                  (c -1)
                  (last null)
                  (current null)
                  (#'next ()
                          (setf last current)
                          (when (> (incf c) (length (aref lines r).text))
                            (setf c 0) (incf r))
                          (setf current
                                (if (or (> r row)
                                        (and (= r row) (>= c col)))
                                    undefined
                                    (or (aref lines r "text" c) "\n"))))
                  (close (aref lines row "text" (1- col)))
                  (open (aref "{[(" (index close "}])")))
                  (stack (list)))
            (next)
            (do ()
                ((or (undefined? current)
                     (or (> r row)
                         (and (= r row) (>= c (1- col)))))
                   (last stack))
              (cond
                ((= current "\"")
                 (next)
                 (do ()
                     ((or (undefined? current)
                          (= current "\""))
                        (when (undefined? current)
                          (return-from parmatch null))
                        (next))
                   (when (= current "\\")
                     (next))
                   (next)))
                ((= current ";")
                 (do ()
                     ((or (undefined? current)
                          (= current "\n")))
                   (next))
                 (when (undefined? current)
                   (return-from parmatch null)))
                ((and (= current "|") (= last "#"))
                 (next)
                 (do ()
                     ((or (undefined? current)
                          (and (= current "#") (= last "|")))
                        (next))
                   (next))
                 (when (undefined? current)
                   (return-from parmatch null)))
                ((= current open)
                 (push (list r c) stack)
                 (next))
                ((= current close)
                 (pop stack)
                 (next))
                (true (next))))))))

(setf mode.macros #())
(setf mode.body-macros #())
(setf mode.functions #())
(setf mode.vars #())

(setf mode.inspect-ilisp
      (lambda (ilisp)
        (ilisp.send "lisp"
                    "(let ((res (list)))
                       (dolist (name (keys (js-code \"window\")))
                         (when ((regexp \"^[dmf][a-zA-Z0-9_]*\\\\$\\\\$.*\").exec name)
                           (let ((x (aref (js-code \"window\") name)))
                             (case (first name)
                               (\"m\" (push (list \"m\"
                                                  (demangle name)
                                                  (and x (str-value x.arglist))
                                                  (and x x.documentation)) res))
                               (\"f\" (push (list \"f\"
                                                  (demangle name)
                                                  (and x (str-value x.arglist))
                                                  (and x x.documentation)) res))
                               (\"d\" (push (list \"d\" (demangle name)) res))))))
                       res)"
                    (lambda (result)
                      (setf mode.body-macros #())
                      (setf mode.macros #())
                      (setf mode.functions #())
                      (setf mode.vars #())
                      (dolist (x (first (json-parse result)))
                        (case (first x)
                          ("m"
                           (setf (aref mode.macros (second x)) (slice x 2))
                           (when (= (slice (or (aref x 2) "") -6) " body)")
                             (setf (aref mode.body-macros (second x)) 1)))
                          ("f"
                           (setf (aref mode.functions (second x)) (slice x 2)))
                          ("d"
                           (setf (aref mode.vars (second x)) 1))))))))

(setf mode.compute-end-context
      (lambda (line)
        (do ((ec (let ((ec (copy line.start-context)))
                   (setf ec.parens (copy line.start-context.parens))
                   ec))
             (text (rstrip line.text))
             (i 0)
             (sections (list)))
            ((>= i (length text))
               (when (> (length line.text) (length text))
                 (push (new-section (length text) (length line.text)
                                    #((background-color "#C0FFC0")))
                       sections))
               (setf line.sections sections)
               ec)
          (cond
            (ec.string
             (let ((i0 i))
               (do () ((or (= i (length text))
                           (= (aref text i) "\"")))
                 (when (and (< i (1- (length text)))
                            (= (aref text i) "\\"))
                   (incf i))
                 (incf i))
               (when (= (aref text i) "\"")
                 (setf ec.string false)
                 (incf i))
               (push (new-section i0 i #((color "#008800"))) sections)))
            (ec.mlcomment
             (let ((i0 i))
               (do () ((or (= i (length text))
                           (= (slice text i (+ i 2)) "|#")))
                 (incf i))
               (when (= (slice text i (+ i 2)) "|#")
                 (setf ec.mlcomment false)
                 (incf i 2))
               (push (new-section i0 i #((color "#888888"))) sections)))
            ((= (slice text i (+ i 2)) "#|")
             (setf ec.mlcomment true))
            ((or (and (= (aref text i) ".") (<= "0" (aref text (1+ i)) "9"))
                 (<= "0" (aref text i) "9"))
             (let ((i0 i))
               (do () ((or (= i (length text))
                           (< (aref text i) "0")
                           (> (aref text i) "9")))
                 (incf i))
               (when (= (aref text i) ".")
                 (incf i)
                 (do () ((or (= i (length text))
                             (< (aref text i) "0")
                             (> (aref text i) "9")))
                   (incf i)))
               (when (find (aref text i) "eE")
                 (incf i)
                 (when (find (aref text i) "+-")
                   (incf i))
                 (do () ((or (= i (length text))
                             (< (aref text i) "0")
                             (> (aref text i) "9")))
                   (incf i)))
               (if (and (< i (length text))
                        (/= (aref text i) " ")
                        (not (find (aref text i) *stopchars*)))
                   (do ()
                       ((or (= i (length text))
                            (find (aref text i) *stopchars*)))
                     (incf i))
                   (push (new-section i0 i #((color "#FF4444")))
                         sections))))
            ((= (aref text i) "(")
             (do ((j (1+ i) (1+ j)))
                 ((or (>= j (length text))
                      (= (aref text j) " ")
                      (= (aref text j) "("))
                    (push (cond
                            ((>= j (length text))
                             (+ i 2))
                            ((= (slice text (1+ i) (+ i 3)) "#'")
                             (+ i 2))
                            ((= (aref text j) " ")
                             (let ((name (slice text (1+ i) j)))
                               (if (aref mode.body-macros name)
                                   (+ i 2)
                                   (+ j 1))))
                            (true j))
                          (or ec.parens (setf ec.parens (list))))
                    (cond
                     ((aref mode.functions (slice text (1+ i) j))
                      (push (new-section (1+ i) j #((color "#008080")))
                            sections)
                      (setf i (1- j)))
                     ((aref mode.macros (slice text (1+ i) j))
                      (push (new-section (1+ i) j #((color "#000080")))
                            sections)
                      (setf i (1- j))))))
             (incf i))
            ((= (aref text i) ")")
             (pop (or ec.parens (setf ec.parens (list))))
             (incf i))
            ((= (aref text i) "\"")
             (setf ec.string true)
             (let ((i0 i))
               (incf i)
               (do () ((or (= i (length text))
                           (= (aref text i) "\"")))
                 (when (and (< i (1- (length text)))
                            (= (aref text i) "\\"))
                   (incf i))
                 (incf i))
               (when (= (aref text i) "\"")
                 (setf ec.string false)
                 (incf i))
               (push (new-section i0 i #((color "#008800"))) sections)))
            ((= (aref text i) ";")
             (push (new-section i (length text) #((color "#888888"))) sections)
             (setf i (length text)))
            ((= (aref text i) " ")
             (do () ((or (= i (length text))
                         (/= (aref text i) " ")))
               (incf i)))
            (true
             (let ((i0 i))
               (incf i)
               (do ()
                   ((or (>= i (length text))
                        (= (aref text i) " ")
                        (find (aref text i) *stopchars*)))
                 (incf i))
               (when (= (aref text (1- i)) ":")
                 (push (new-section i0 i #((color "#800080"))) sections))))))))

(setf mode.autoindent
      (lambda (lines row)
        (when (> row 0)
          (let ((line (aref lines (1- row)))
                (newline (aref lines row)))
            (let ((indent (last (or (mode.compute-end-context line).parens
                                    (list 0)))))
              (when (> indent 0)
                (setf newline.text
                      (+ (str-repeat " " indent)
                         (lstrip newline.text))))
              indent)))))

(export mode)
