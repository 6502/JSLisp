(defvar mode
  #((parmatch (lambda (lines row col)
                (block parmatch
                  (let** ((r 0)
                          (c -1)
                          (last null)
                          (current null)
                          (#'next ()
                                  (setf last current)
                                  (when (> (incf c) (length (aref lines r).text))
                                    (setf c 0) (incf r))
                                  (setf current
                                        (if (or (> r row)
                                                (and (= r row) (>= c col)))
                                            undefined
                                            (or (aref lines r "text" c) "\n"))))
                          (close (aref lines row "text" (1- col)))
                          (open (aref "{[(" (index close "}])")))
                          (stack (list)))
                    (next)
                    (do ()
                        ((or (undefined? current)
                             (or (> r row)
                                 (and (= r row) (>= c (1- col)))))
                         (last stack))
                      (cond
                       ((= current "\"")
                        (next)
                        (do ()
                            ((or (undefined? current)
                                 (= current "\""))
                             (when (undefined? current)
                               (return-from parmatch null))
                             (next))
                          (when (= current "\\")
                            (next))
                          (next)))
                       ((= current ";")
                        (do ()
                            ((or (undefined? current)
                                 (= current "\n")))
                          (next))
                        (when (undefined? current)
                          (return-from parmatch null)))
                       ((and (= current "|") (= last "#"))
                        (next)
                        (do ()
                            ((or (undefined? current)
                                 (and (= current "#") (= last "|")))
                             (next))
                          (next))
                        (when (undefined? current)
                          (return-from parmatch null)))
                       ((= current open)
                        (push (list r c) stack)
                        (next))
                       ((= current close)
                        (pop stack)
                        (next))
                       (true (next))))))))

    (compute-end-context (lambda (line)
                           (do ((ec (copy line.start-context))
                                (text (rstrip line.text))
                                (i 0)
                                (sections (list)))
                               ((>= i (length text))
                                (when (> (length line.text) (length text))
                                  (push (new-section (length text) (length line.text)
                                                     #((background-color "#C0FFC0")))
                                        sections))
                                (setf line.sections sections)
                                ec)
                             (cond
                              (ec.string
                               (let ((i0 i))
                                 (do () ((or (= i (length text))
                                             (= (aref text i) "\"")))
                                   (when (and (< i (1- (length text)))
                                              (= (aref text i) "\\"))
                                     (incf i))
                                   (incf i))
                                 (when (= (aref text i) "\"")
                                   (setf ec.string false)
                                   (incf i))
                                 (push (new-section i0 i #((color "#008800"))) sections)))
                              (ec.mlcomment
                               (let ((i0 i))
                                 (do () ((or (= i (length text))
                                             (= (slice text i (+ i 2)) "|#")))
                                   (incf i))
                                 (when (= (slice text i (+ i 2)) "|#")
                                   (setf ec.mlcomment false)
                                   (incf i 2))
                                 (push (new-section i0 i #((color "#888888"))) sections)))
                              ((= (slice text i (+ i 2)) "#|")
                               (setf ec.mlcomment true))
                              ((or (and (= (aref text i) ".") (<= "0" (aref text (1+ i)) "9"))
                                   (<= "0" (aref text i) "9"))
                               (let ((i0 i))
                                 (do () ((or (= i (length text))
                                             (< (aref text i) "0")
                                             (> (aref text i) "9")))
                                   (incf i))
                                 (when (= (aref text i) ".")
                                   (incf i)
                                   (do () ((or (= i (length text))
                                               (< (aref text i) "0")
                                               (> (aref text i) "9")))
                                     (incf i)))
                                 (when (find (aref text i) "eE")
                                   (incf i)
                                   (when (find (aref text i) "+-")
                                     (incf i))
                                   (do () ((or (= i (length text))
                                               (< (aref text i) "0")
                                               (> (aref text i) "9")))
                                     (incf i)))
                                 (push (new-section i0 i #((color "#FF4444"))) sections)))
                              ((find (aref text i) "{[()]}")
                               (let ((i0 i))
                                 (do () ((or (= i (length text))
                                             (not (find (aref text i) "{[()]}"))))
                                   (incf i))
                                 (push (new-section i0 i #((color "#808080"))) sections)))
                              ((= (aref text i) "\"")
                               (setf ec.string true)
                               (let ((i0 i))
                                 (incf i)
                                 (do () ((or (= i (length text))
                                             (= (aref text i) "\"")))
                                   (when (and (< i (1- (length text)))
                                              (= (aref text i) "\\"))
                                     (incf i))
                                   (incf i))
                                 (when (= (aref text i) "\"")
                                   (setf ec.string false)
                                   (incf i))
                                 (push (new-section i0 i #((color "#008800"))) sections)))
                              ((= (aref text i) ";")
                               (push (new-section i (length text) #((color "#888888"))) sections)
                               (setf i (length text)))
                              ((= (aref text i) " ")
                               (do () ((or (= i (length text))
                                           (/= (aref text i) " ")))
                                 (incf i)))
                              (true
                               (incf i))))))
    (autoindent (lambda (lines row)
                  (when (> row 0)
                    (let ((line (aref lines (1- row)))
                          (newline (aref lines row)))
                      (let ((indent (length (first ((regexp "^ *").exec line.text)))))
                        (when (> indent 0)
                          (setf newline.text
                                (+ (slice line.text 0 indent)
                                   newline.text)))
                        indent)))))))

(export mode)
