(defvar mode #())

(import (new-section) from editor)

(setf mode.parmatch
      (lambda (lines row col)
        (block parmatch
          (let** ((r 0)
                  (c -1)
                  (last null)
                  (current null)
                  (#'next ()
                          (setf last current)
                          (when (> (incf c) (length (aref lines r).text))
                            (setf c 0) (incf r))
                          (setf current
                                (if (or (> r row)
                                        (and (= r row) (>= c col)))
                                    undefined
                                    (or (aref lines r "text" c) "\n"))))
                  (close (aref lines row "text" (1- col)))
                  (open (aref "{[(" (index close "}])")))
                  (stack (list)))
            (next)
            (do ()
                ((or (undefined? current)
                     (or (> r row)
                         (and (= r row) (>= c (1- col)))))
                   (last stack))
              (cond
                ((= current "\"")
                 (next)
                 (do ()
                     ((or (undefined? current)
                          (= current "\""))
                        (when (undefined? current)
                          (return-from parmatch null))
                        (next))
                   (when (= current "\\")
                     (next))
                   (next)))
                ((= current ";")
                 (do ()
                     ((or (undefined? current)
                          (= current "\n")))
                   (next))
                 (when (undefined? current)
                   (return-from parmatch null)))
                ((and (= current "|") (= last "#"))
                 (next)
                 (do ()
                     ((or (undefined? current)
                          (and (= current "#") (= last "|")))
                        (next))
                   (next))
                 (when (undefined? current)
                   (return-from parmatch null)))
                ((= current open)
                 (push (list r c) stack)
                 (next))
                ((= current close)
                 (pop stack)
                 (next))
                (true (next))))))))

(setf mode.compute-end-context
      (lambda (line)
        (do ((ec (let ((ec (copy line.start-context)))
                   (setf ec.parens (copy line.start-context.parens))
                   ec))
             (text (rstrip line.text))
             (i 0)
             (sections (list)))
            ((>= i (length text))
               (when (> (length line.text) (length text))
                 (push (new-section (length text) (length line.text)
                                    #((background-color "#C0FFC0")))
                       sections))
               (setf line.sections sections)
               ec)
          (cond
            (ec.string
             (let ((i0 i))
               (do () ((or (= i (length text))
                           (= (aref text i) "\"")))
                 (when (and (< i (1- (length text)))
                            (= (aref text i) "\\"))
                   (incf i))
                 (incf i))
               (when (= (aref text i) "\"")
                 (setf ec.string false)
                 (incf i))
               (push (new-section i0 i #((color "#008800"))) sections)))
            (ec.mlcomment
             (let ((i0 i))
               (do () ((or (= i (length text))
                           (= (slice text i (+ i 2)) "|#")))
                 (incf i))
               (when (= (slice text i (+ i 2)) "|#")
                 (setf ec.mlcomment false)
                 (incf i 2))
               (push (new-section i0 i #((color "#888888"))) sections)))
            ((= (slice text i (+ i 2)) "#|")
             (setf ec.mlcomment true))
            ((or (and (= (aref text i) ".") (<= "0" (aref text (1+ i)) "9"))
                 (<= "0" (aref text i) "9"))
             (let ((i0 i))
               (do () ((or (= i (length text))
                           (< (aref text i) "0")
                           (> (aref text i) "9")))
                 (incf i))
               (when (= (aref text i) ".")
                 (incf i)
                 (do () ((or (= i (length text))
                             (< (aref text i) "0")
                             (> (aref text i) "9")))
                   (incf i)))
               (when (find (aref text i) "eE")
                 (incf i)
                 (when (find (aref text i) "+-")
                   (incf i))
                 (do () ((or (= i (length text))
                             (< (aref text i) "0")
                             (> (aref text i) "9")))
                   (incf i)))
               (if (and (< i (length text))
                        (/= (aref text i) " ")
                        (not (find (aref text i) *stopchars*)))
                   (do ()
                       ((or (= i (length text))
                            (find (aref text i) *stopchars*)))
                     (incf i))
                   (push (new-section i0 i #((color "#FF4444")))
                         sections))))
            ((= (aref text i) "(")
             (do ((j (1+ i) (1+ j)))
                 ((or (>= j (length text))
                      (= (aref text j) " ")
                      (= (aref text j) "("))
                    (push (cond
                            ((>= j (length text))
                             (+ i 2))
                            ((= (slice text (1+ i) (+ i 3)) "#'")
                             (+ i 2))
                            ((= (aref text j) " ")
                             (let* ((name (slice text (1+ i) j))
                                    (s1 (intern name "" true))
                                    (s2 (intern name *current-module* true))
                                    (m (or (and s1 (symbol-macro s1))
                                           (and s2 (symbol-macro s2)))))
                               (if (and m m.arglist (= (last m.arglist) 'body))
                                   (+ i 2)
                                   (+ j 1))))
                            (true j))
                          (or ec.parens (setf ec.parens (list))))))
             (incf i))
            ((= (aref text i) ")")
             (pop (or ec.parens (setf ec.parens (list))))
             (incf i))
            ((= (aref text i) "\"")
             (setf ec.string true)
             (let ((i0 i))
               (incf i)
               (do () ((or (= i (length text))
                           (= (aref text i) "\"")))
                 (when (and (< i (1- (length text)))
                            (= (aref text i) "\\"))
                   (incf i))
                 (incf i))
               (when (= (aref text i) "\"")
                 (setf ec.string false)
                 (incf i))
               (push (new-section i0 i #((color "#008800"))) sections)))
            ((= (aref text i) ";")
             (push (new-section i (length text) #((color "#888888"))) sections)
             (setf i (length text)))
            ((= (aref text i) " ")
             (do () ((or (= i (length text))
                         (/= (aref text i) " ")))
               (incf i)))
            (true
             (incf i)
             (do ()
                 ((or (>= i (length text))
                      (= (aref text i) " ")
                      (find (aref text i) *stopchars*)))
               (incf i)))))))

(setf mode.autoindent
      (lambda (lines row)
        (when (> row 0)
          (let ((line (aref lines (1- row)))
                (newline (aref lines row)))
            (let ((indent (last (or (mode.compute-end-context line).parens
                                    (list 0)))))
              (when (> indent 0)
                (setf newline.text
                      (+ (str-repeat " " indent)
                         (lstrip newline.text))))
              indent)))))

(export mode)
